# New Year, New Website

Happy 2026! It's been a long time since I've made a post here; but fear not. I have brought back my New Year's resolution of making one post per week for the year of 2026. You might notice that things are looking different around here. That's because I have moved off of `mkdocs` and set up a new static site generator.

## Why Leave Mkdocs?

In late 2023, I [transitioned](./2023-08-12-mkdocs) from a very old Jekyll-generated website over to a Python-based, trendy static site generator (SSG) called [`mkdocs`](https://www.mkdocs.org/), which has several community-created and maintained themes. One of the most popular themes is called [`mkdocs-material`](https://squidfunk.github.io/mkdocs-material/), a very responsive and customizable theme so advanced, it even had its own plugins to further customize it and extend its functionality. Needless to say, I was a huge fan, even [contributing](./2024-01-05-contributing) to it, and used it up until today when I am launching my new website. But why have I suddenly decided to stop using it?

The `mkdocs-material` maintainers have made a [blog post](https://squidfunk.github.io/mkdocs-material/blog/2025/11/11/insiders-now-free-for-everyone/) and official [GitHub issue](https://github.com/squidfunk/mkdocs-material/issues/8523) detailing that the project has now entered maintenance mode due to the team pursuing a new project called [Zensical](https://zensical.org/), another static site generator. Zensical is relatively new and untested, and the team may be releasing breaking changes as they continue to develop its features.

Because `mkdocs-material` is now in maintenance mode, the team will no longer be adding new features to it and will only be providing security updates for about a year from November 2025. Eventually it will be discontinued altogether unless another team decides to make a fork of the project and continue maintaining it. This made me reflect on my website stack and realize just how much 3rd party software I am dependent on. Every feature that was embedded on my website was either part of `mkdocs-material` or better yet a 3rd party plugin that depended on `mkdocs-material`, such as:

- Navigation sidebar
- The search bar
- Dark/light themes
- Blog structure, posting, and tags
- Rendering math equations
- Rendering flowcharts (I only used this [once](./2024-04-28-gatekeep))
- Code syntax highlighting
- "Copy" button in code blocks
- Google Analytics
- Cookie consent

## The Search for a New SSG

I debated internally for a long time how to structure a new version of my website that would depend less on 3rd party software. I considered migrating my blog over to a website like [Medium.com](https://medium.com/) similar to how I [migrated all my photos to Instagram](./2024-01-02-website-updates#instagram). Then my domain could redirect to a simple HTML page that has my name and social links, so I would have as little as possible on my actual website.

Another idea I had was to actually just write all the HTML from scratch. and I would not depend on *any* 3rd party software, but I quickly ruled this out because that would be a huge pain to maintain myself, and I prefer the simplicity of Markdown.

My final idea was to search for another static site generator with good community support and minimal 3rd party plugins and dependencies. I did my research on Google Gemini (AI chatbot) and by reading several blog posts by others in my situation. I played around with, or at least considered, all of the following:

1. **mkdocs** I could switch to a different theme, but I may eventually run into the same problems.
1. **Jekyll** I've used it before and is well integrated with GitHub pages, and GitHub officially supports several themes.
1. **Hugo** Dependent on *Go*, which I am not proficient in (a.k.a. never used before.) Also, I would need to install a community-built theme, similar to `mkdocs`.
1. **Astro** Seems well-supported, has paid tiers, but even the starter project has so much bloat.
1. **Hexo** Runs on NodeJs (which I [love](./2024-12-07-npm-monorepo)) but all themes are maintained by the community.
1. **Eleventy** Also runs on NodeJs, absolutely no bloat, but you have to develop the theme and plugins yourself.

## Choosing Eleventy

Eventually I decided to use a SSG called [Eleventy (11ty)](https://www.11ty.dev/). As a NodeJS developer, it was the easiest for me to get started, and in fact I didn't even need to install any dependencies since I can run it with the Node package executor. However, it produced the most bare-bones output by itself. For example, starting with this markdown file...

```md
# My Post

Here is a paragraph.
```

...and running this command...

```shell
npx @11ty/eleventy
```

...produces this result:

```html
<h1>My Post</h1>
<p>Here is a paragraph.</p>
```

As the developer, you can customize this a lot. Eleventy uses the [Liquid](https://liquidjs.com) templating language (as well as others) within the inputted Markdown/HTML files. You can create HTML Layouts in which the content is rendered, for example to add headers, footers, and metadata. I know, I know - *a dependency*. While the amount of these can be minimized, unfortunately some are unavoidable. For example, `mkdocs` depended on a similar templating language called [Jinja2](https://pypi.org/project/Jinja2/).

## Building the Features

In this section, I outline how I rebuilt some of the [features](#why-leave-mkdocs) that I used in `mkdocs`.

### Navigation

If I wanted my website to be usable at all, I would need to add some sort of navigation for all my pages. Luckily, Eleventy does provide some built-in functionality for collections of pages and a pagination feature. I was able to group all my posts into `collections.post` by adding the "post" tag in front matter (basically page metadata), like this:

```md
---
tags:
  - post
---
# My Post

Here is a paragraph.
```

Since all of my posts will have the same front matter, I am able to set defaults within a **directory data file** called `posts.json`:

```json
{
    "tags": "post",
    "permalink": "{{ page.date | date:'%Y-%m-%d-' }}{{ page.fileSlug | slugify }}/"
}
```

Here, I also use Liquid to set the permalink for each post to `YYYY-MM-DD-slug` which guarantees a unique and easily identifiable permalink for each of my posts. I could have also added `title: My Post` within the front matter and used `{{ title | slugify }}` instead of `{{ page.fileSlug | slugify }}`, it's purely a design choice. I figured that my file names change less frequently than my post titles. Also by adding the post date into the file path, I didn't need to add `date:` to my front matter, either. A hidden benefit of this was that I could avoid front matter altogether.

## Page Metadata

For each post, I wanted 3 pieces of metadata:

1. Title of post
1. Description
1. Date posted

Since I didn't have the page title or description within front matter, I needed to create a custom filter to generate the page title and description based on the page content. I achieved this by reading the template content, which is the Eleventy output for each page - which is raw HTML code, shown [above](#choosing-eleventy). My methodology was to generate the page title using the first header and the description using the first paragraph. After a *lot* of trial and error (thanks [Regex101](https://regex101.com/)), I achieved this using a regular expression to extract the text content and strip HTML tags for these elements.

### Title Filter

```js
const firstHeader = post.match(/<(h[1-6])[^>]*>(.+?)<\/\1>/s); // Match first <h1> through <h6>
if (firstHeader) {
    return firstHeader[2].replaceAll(/<[^>]+>/g, ''); // Strip HTML tags
} else {
    return 'Untitled';
}
```

### Description Filter

```js
const firstPara = post.match(/<p[^>]*>(.+?)<\/p>/s); // Match first <p>
if (firstPara) {
    return firstPara[1].replaceAll(/<[^>]+>/g, ''); // Strip HTML tags
} else {
    return '';
}
```

### Page Date

As for the page date, normally this is achieved through front matter, and accessed through the `date` or `data.date` variable, depending on where you are accessing it from.

```yaml
date: 2025-12-31
```

If the date doesn't exist, Eleventy then checks the file path, and finally the file creation date as fallbacks. Because I included the date within the file path itself, I can access that value using the `page.date` variable.
